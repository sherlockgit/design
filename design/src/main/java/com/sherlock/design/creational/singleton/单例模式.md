## 抽象工厂
* 定义：保证一个类仅有一个实例，并且提供一个全局访问点
* 类型：创建型
* 优点：在内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用；设置了全局访问点，严格控制访问
* 缺点：没有接口，扩展困难

### 重点
* 私有构造器
* 线程安全
* 延迟加载
* 序列化和反序列化安全
* 反射（反射攻击）

### 实用技巧
* 反编译
* 内存原理
* 多线程debug

### 适用场景
* 想确保任何情况下都绝对只有一个实例

### 相关设计模式
* 单例模式与工厂模式
* 单例模式与享元模式

### 懒汉式
#### 1.LazySingleton
* 存在线程安全问题，并发情况下可能会重复创建对象
#### 2.SyncLazySingleton
* 解决了线程安全问题，但该方式存在性能较差的锁争用
#### 3.DoubleCheckSyncLazySingleton
* 双重校验的单例模式，解决了线程安全问题，叫好的锁争用性能，但存在指令重排序问题
* 一个对象的创建过程包括 1.分配对象的内存；2.初始化对象；3.将创建的对象指向刚分配的内存地址
* 但出现指令重排序问题时，可能会先执行“3.将创建的对象指向刚分配的内存地址”再执行“2.初始化对象”
#### 4.VolatileDoubleCheckSyncLazySingleton
* 由于加上了Volatile关键字，可防止指令重排序问题
#### 5.StaticInnerClassSingleton
* 静态内部类的单例模式（基于类的初始化过程中会为其创建一个初始锁。这个机制防止出现线程安全问题），同样可防止指令重排序问题
#### 5.AntiReflectLazySingleton
* 防反射攻击（懒汉式）实际无法完全防御,反射可以修改任何除了final以外的任何参数

### 饿汉式
#### 1.HungerSingleton
* 类初始化时生成的订单例对象
#### 2.AntiReflectHungerSingleton
* 防反射攻击的饿汉式单例对象
#### 3.AnitDeserializedHungerSingleton
* 防序列化、反序列化攻击的饿汉式单例对象

### 枚举形式的单例对象(饿汉式)
#### 1.EnumSingleton
* 防序列化、反序列化攻击。最优雅的单例对象写法

### 容器形式的单例对象
#### 1.ContainerSingleton
* 方便管理众多单例对象，但防止不了序列化，反序列化攻击，需要根据实际的业务场景

### 基于线程中的单例对象
#### 1.ThreadLocalSingleton
* 基于线程中的单例对象，独立于每个线程独有一份的单例对象


### 相关源码
#### 1.Runtime(饿汉式)
* 来源：JDK
* 介绍：每个Java应用程序都有一个类Runtime的实例，它允许应用程序与运行应用程序的环境进行交互。当前运行时可以从getRuntime方法获得。
#### 2.Desktop(容器形式的单例对象)
* 来源：JDK
* 介绍：Desktop类允许与各种桌面功能进行交互。更多应用于CS架构
#### 2.ErrorContext(基于线程中的单例对象)
* 来源：mybatis
* 介绍：mybatis 的错误上下文
  

### 注
#### 指令重排序
* 在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序
#### 类加载的时机
* ‌通过new关键字实例化对象‌：当通过new关键字创建对象时，如果对应的类尚未加载，则会触发类的加载。
* ‌读取或设置类的静态变量‌：访问类的静态变量时，如果类尚未初始化，则会进行初始化。
* ‌调用类的静态方法‌：调用类的静态方法时，如果类尚未初始化，则会进行初始化。
* ‌反射调用‌：通过反射方式执行上述三种行为时，也会触发类的加载和初始化
* 执行main函数‌：当执行main函数所在的类时，该类会被加载和初始化。

    




## 抽象工厂
* 定义：保证一个类仅有一个实例，并且提供一个全局访问点
* 类型：创建型
* 优点：在内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用；设置了全局访问点，严格控制访问
* 缺点：没有接口，扩展困难

### 重点
* 私有构造器
* 线程安全
* 延迟加载
* 序列化和反序列化安全
* 反射（反射攻击）

### 实用技巧
* 反编译
* 内存原理
* 多线程debug

### 适用场景
* 想确保任何情况下都绝对只有一个实例

### 相关设计模式
* 单例模式与工厂模式
* 单例模式与享元模式

### 懒汉式
#### 1.LazySingleton
* 存在线程安全问题，并发情况下可能会重复创建对象
#### 2.SyncLazySingleton
* 解决了线程安全问题，但该方式存在性能较差的锁争用
#### 3.DoubleCheckSyncLazySingleton
* 双重校验的单例模式，解决了线程安全问题，叫好的锁争用性能，但存在指令重排序问题
* 一个对象的创建过程包括 1.分配对象的内存；2.初始化对象；3.将创建的对象指向刚分配的内存地址
* 但出现指令重排序问题时，可能会先执行“3.将创建的对象指向刚分配的内存地址”再执行“2.初始化对象”
#### 4.VolatileDoubleCheckSyncLazySingleton
* 由于加上了Volatile关键字，可防止指令重排序问题
#### 5.StaticInnerClassSingleton
* 静态内部类的单例模式（基于类的初始化过程中会为其创建一个初始锁。这个机制防止出现线程安全问题），同样可防止指令重排序问题

### 注
#### 指令重排序
* 在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序
#### 类加载的时机
* ‌通过new关键字实例化对象‌：当通过new关键字创建对象时，如果对应的类尚未加载，则会触发类的加载。
* ‌读取或设置类的静态变量‌：访问类的静态变量时，如果类尚未初始化，则会进行初始化。
* ‌调用类的静态方法‌：调用类的静态方法时，如果类尚未初始化，则会进行初始化。
* ‌反射调用‌：通过反射方式执行上述三种行为时，也会触发类的加载和初始化
* 执行main函数‌：当执行main函数所在的类时，该类会被加载和初始化。

    



